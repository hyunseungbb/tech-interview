# Database



### DB에 접근하는 단계

1. 웹 컨테이너가 실행되면서 db와 연결된 connection 객체들을 미리 pool에 저장한다.
2. db요청 시, pool에서 connection 객체를 가져와 db에 접근한다.
3. 처리가 끝나면 다시 pool에 반환한다.



- connection이 부족하다면?
  - 해당 클라이언트는 대기 상태로 전환시키고 pool의 connection이 반환되면 대기 상태에 있는 클라이언트에게 순차적으로 제공합니다.
- connection을 사용하는 이유
  - 매 연결마다 connection 객체를 생성하고 소멸시키는 비용을 줄일 수 있다.
  - 미리 생성된 connection 객체를 사용하기 때문에 db접근 시간이 단축된다.
  - db에 접근하는 connection 수를 제한하여 메모리와 db에 걸리는 부하를 조절할 수 있다.



### 정규화

- 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업.
- 나쁜 릴레이션의 어트리뷰트를 나누어서 좋은 릴레이션으로 분배하는 작업.
- 나쁜 릴레이션은 엔티티를 구성하는 어트리뷰트 간 함수적 종속성으로 판단한다.
- 함수적 종속 : X의 값에 따라 Y값이 결정될 때 X -> Y로 표현하고, Y는 X에 대해 함수적 종속이라고 한다. 또한 X를 결정자, Y를 종속자라고 한다.
- 릴레이션이 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 정의되고, 그 정규형을 만족하지 못하는 릴레이션을 나쁜 릴레이션으로 파악한다. 

- 제 1 정규형
  - 어트리뷰트의 도메인이 오직 원자값만을 포함하고, 튜플의 모든 어트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다.
  - 비 원자적 어트리뷰트들 : 복합 어트리뷰트, 다중값 어트리뷰트, 중첩 릴레이션
- 제 2 정규형
  - 모든 비주요 어트리뷰트들이 주요 어트리뷰트에 대해 **완전 함수적 종속**이다.
  - 완전 함수적 종속 : X- > Y 라고 가정했을 때, X의 어떤 어트리뷰트라도 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다. 즉, 기본키의 부분집합이 결정자가 되어선 안된다는 것을 말한다.
  - 1NF에서 후보키 K와 후보키가 아닌 속성 A가 있을  때, A를 결졍하기 위해 K의 부분집합이 아닌 모든 속성을 참조해야 하는 경우 2NF이다. 
  - 제 1정규형에 속하면서, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제2정규형이다.
- 제 3 정규형
  -  어떠한 비주요 어트리뷰트도 기본키에 대해 이행 함수적 종속되지 않는다.
  - 이행 함수적 종속 : X - > Y, Y -> Z 인 경우에 추론될 수 있는 X -> Z의 종속관계를 말한다.
- BCNF(Boyce-Codd) 정규형
  - 제 3정규화를 진행한 테이블에 대해 모든결정자가 후보키가 되도록 테이블을 분해하는 것이다.
  - 여러 후보 키가 존재하는 릴레이션에 해당하는 정규화 내용이다. 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3 정규형을 보완하는데 의미가 있다. 



### Key의 종류

- 기본키
  - 한 릴레이션에서 튜플을 유일하게 구별할 수 있는 어트리뷰트
- 후보키
  - 튜플을 유일하게 식별하기 위해 사용하는 어트리뷰트의 부분집합
  - 기본키로 사용할 수 있는 어트리뷰트들
  - 유일성과 최소성을 만족해야 한다.
- 대체키
- 슈퍼키
- 외래키



### 트랜잭션



### 인덱스

말 그대로 인덱스로서, 데이터베이스에서 조회를 더욱 빠르게 할 수 있는 방법입니다. 테이블의 모든 데이터를 검색해서 원하는 데이터를 가져오는 데 시간이 많이 걸리기 때문에, 칼럼의 값과 저장된 주소를 key와 value 쌍으로 만들어 놓는 방식입니다.

일반적으로 B+tree알고리즘을 사용해서 인덱스를 관리한다.

#### [B-tree 알고리즘](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree)

- 동등관계에 특화된 해시테이블과 달리 범위 탐색에 특화되어 있다.

#### [B+tree 알고리즘](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Plus-Tree)

- 동작 방식은 B-tree와 유사하지만, 차이점은 모든 key, data가 리프노드에 모여 있고, 리프노드가 연결리스트의 형태를 띄어 선형검색이 가능하다.

- Cardinality가 낮은 칼럼에 인덱스 효과를 기대하기 어려운 이유
  - 중복된 값이 많아질수록 B-tree를 따라가는 데 조작이 증가하기 때문에
