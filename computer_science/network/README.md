[toc]

# 네트워크

## OSI 7계층

**7계층을 나누는 이유**

통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기 때문이다.

![img](README.assets/img.jpg)



**1) 물리(Physical)**

> 케이블, 허브, 리피터 등 

데이터를 전기적 신호로 변환해서 주고받는 기능을 진행하는 계층.

데이터를 전송하는 역할만을 진행한다.



**2) 데이터 링크(Data Link)**

> 브릿지, 스위치

물리 계층으로 송수신되는 정보를 관리하여 안전하게 전달되도록 도와주는 역할.

브릿지나 스위치를 통해 Mac주소를 프레임에 부여하여 물리계층에서 받은 정보를 전달한다.

데이터 단위 : 프레임



**3) 네트워크(Network)**

> 라우터, IP

데이터를 목적지까지 가장 안전하고 빠르게 전달하는(라우팅) 역할.

라우터를 통해 이동 경로를 선택하고, IP 주소를 부여하여 패킷을 전달해준다.

라우팅, 흐름 제어, 오류 제어, 세그멘테이션 등을 수행한다.



**4) 전송(Transport)**

> TCP, UDP

TCP와 UDP 프로토콜을 통해 통신을 활성화한다. 포트를 열어두고, 프로그램들이 전송을 할 수 있도록 제공해준다.

TCP: 신뢰성, 연결지향적

UDP: 비신뢰성, 비연결성, 실시간

데이터 단위 : 세그먼트



**5) 세션(Session)**

> API, Socket

응용 프로세스가 통신을 관리하기 위한 방법을 정의한다. 데이터가 통신하기 위한 논리적 연결을 담당한다.

TCP/IP 세션을 만들고 없애는 역할을 담당한다.



**6) 표현(Presentation) **

> JPEG, MPEG 등

데이터 표현에 대한 독립성을 제공하고 암호화하는 역할을 한다.

파일 인코딩 및 명령어 포장, 압축, 암호화



**7) 응용(Application)**

> HTTP, FTP, DNS 등

응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.

사용자 인터페이스, 전자우편, 데이터베이스 관리 등의 서비스를 제공한다.



## TCP와 IP

## TCP와 UDP

### TCP의 흐름제어

송신 측에서 수신 측의 데이터 처리속도를 파악하고 데이터 전송속도를 결정하는 것.

- stop and wait
- sliding window
  - 수신 측이 한 번에 처리할 수 있는 데이터의 양(버퍼의 크기)을 송신 측에 알려주는 방식.
  - 송신 측 윈도우의 크기는 3-Way Handshake때 결정된다.

### TCP의 오류제어



## TCP의 3-way handshake와 4-way handshake

https://asfirstalways.tistory.com/356



- 왜 두 종류의 패킷을 주고받는것일까요?

- 2-way로 연결 성립을 하게 되면 무슨 일이 일어날까요?

- 왜 SYN에 임의의 난수를 지정할까요?



### stateless한 http가 사용자 정보를 저장할 수 있는 이유는?

쿠키와 세션을 이용한다.



### 쿠키와 세션이란?

쿠키는 웹 브라우저가 보관하는 키-밸류 형태의 데이터입니다. 웹 서버에서 쿠키를 전달받아 이후 요청을 보낼 때 쿠키를 헤더에 실어서 함께 전송함으로써 상태를 유지할 수 있습니다.

하지만 쿠키만으로는 통신 중간에 탈취의 위험이 있기 때문에 이를 보완하기 위해 세션이 필요합니다.

세션또한 클라이언트의 상태를 저장하는 데이터로, 브라우저에 저장되는 쿠키와 달리 서버에 저장이됩니다. 



### 쿠키&세션 vs JWT 토큰 비교

쿠키&세션의 장점은 각 사용자마다 고유한 세션ID가 발급되기 때문에 요청마다 회원정보를 확인할 필요가 없습니다.

세션의 단점은 세션 저장소를 별도로 두어야 한다는 것입니다. 특히 다중 서버 환경에서 sticky session방식은 매우 비효율적이기 때문에 세션 스토리지를 서버에서 분리해서 사용하기도 하지만,  이 것 자체에 대한 비용이 있습니다.



JWT 토큰의 장점은 헤더와 페이로드를 가지고 시그니처를 생성하기 때문에 서버측의 비밀키가 유출되지 않는 이상 데이터 위변조를 막을 수 있습니다. 또한 인증 정보에 대한 별도의 저장소가 필요하지 않습니다.

JWT 토큰의 단점은 토큰을 서버에서 임의로 제거할 수 가 없다는 것입니다. 따라서 보안 취약점을 해결하기 위해 토큰 생명주기에 대한 관리가 따로 필요합니다. 짧은 만료기한을 설정하거나, *리프레시 토큰*을 사용하는 방식 등을 고려해야 합니다. 

리프레시 토큰을 관리하기 위해서는 추가적인 저장공간을 서버에 별도로 두어야 할까? 어떻게 관리를 해야할까? 

유저 DB에 리프레시토큰 속성 추가



토큰을 브라우저에서 어디서 저장하는 것이 좋을까?

1. http-only 속성의 쿠키 - 자바스크립트환경에서 접근할 수 없다.

2. local storage - XSS 공격에 취약
3. session storage - XSS 공격에 취약



### 다중 서버 환경에서 session은 어떻게 공유하고 관리할까?

sticky session 방식 - 로드밸런서가 세션을 생성한 서버로만 리다이렉트한다. 정합성 이슈에서 자유롭지만 트래픽이 집중될 위험이 있다. 장애에 취약하다.



all-to-all Session Replication

한 세션저장소에 변경사항이 발생하면 모든 서버의 세션저장소로 해당 세션을 복제한다.

많은 메모리가 필요하고, 서버 수가 늘어날수록 성능저하가 심하다.



**세션스토리지분리**

세션을 효율적으로 공유할 수 있다.

가용성과 트래픽 분산을 모두 가져갈 수 있다.



